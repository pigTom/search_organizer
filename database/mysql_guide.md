并发控制完全指南
> **最后更新**：2026-01-15

## 目录

1. [什么是事务](#什么是事务)
2. [ACID 特性](#acid-特性)
3. [事务隔离级别](#事务隔离级别)
4. [MySQL 如何实现隔离级别](#mysql-如何实现隔离级别)
5. [MVCC 多版本并发控制](#mvcc-多版本并发控制)
6. [锁机制详解](#锁机制详解)
7. [高并发下的可见性问题](#高并发下的可见性问题)
8. [实战与最佳实践](#实战与最佳实践)
9. [常见问题解答](#常见问题解答)

---

## 什么是事务

### 通俗理解

想象你在银行转账：从账户 A 转 1000 元到账户 B。这个操作包含两步：

1. 账户 A 减少 1000 元
2. 账户 B 增加 1000 元

**如果第一步成功，第二步失败了怎么办？** 钱从 A 扣了，但 B 没收到，钱就"凭空消失"了！

**事务（Transaction）** 就是为了解决这个问题：要么两步都成功，要么都不执行，不会出现"做了一半"的情况。

### 正式定义

**事务（Transaction）** 是数据库操作的最小逻辑工作单元，由一组 SQL 语句组成。事务具有以下特点：

1. **原子性**：事务中的所有操作要么全部完成，要么全部不执行
2. **一致性**：事务执行前后，数据库都处于一致状态
3. **隔离性**：并发事务之间互不干扰
4. **持久性**：事务一旦提交，结果永久保存

### 事务的基本操作

```sql
-- 开始事务
START TRANSACTION;
-- 或者
BEGIN;

-- 执行一系列操作
UPDATE accounts SET balance = balance - 1000 WHERE id = 'A';
UPDATE accounts SET balance = balance + 1000 WHERE id = 'B';

-- 提交事务（所有更改生效）
COMMIT;

-- 或者回滚事务（撤销所有更改）
ROLLBACK;
```

### 事务的状态

```
事务的生命周期：

┌─────────┐    START      ┌─────────┐
│  未开始  │ ──────────→  │  活动中  │
└─────────┘              └────┬────┘
                              │
                    ┌─────────┴─────────┐
                    ↓                   ↓
              ┌──────────┐        ┌──────────┐
              │ 部分提交  │        │   失败   │
              └────┬─────┘        └────┬─────┘
                   │                   │
                   ↓                   ↓
              ┌──────────┐        ┌──────────┐
              │  已提交   │        │  已回滚   │
              └──────────┘        └──────────┘
```

---

## ACID 特性

### 概述

```
┌─────────────────────────────────────────────────────┐
│                    ACID 特性                         │
├─────────────────────────────────────────────────────┤
│                                                      │
│  A - Atomicity    (原子性)  - 要么全做，要么全不做   │
│  C - Consistency  (一致性)  - 数据始终保持正确状态   │
│  I - Isolation    (隔离性)  - 事务之间互不干扰       │
│  D - Durability   (持久性)  - 提交后永久保存         │
│                                                      │
└─────────────────────────────────────────────────────┘
```

### 1. 原子性（Atomicity）

```
含义：事务中的操作是不可分割的整体

生活比喻：
├─ 就像"怀孕"，要么怀上了，要么没怀上
├─ 不存在"怀了一半"的状态
└─ 转账要么成功，要么就像没发生过

MySQL 实现方式：
├─ 通过 Undo Log（回滚日志）实现
├─ 事务执行前，先记录数据的原始状态
├─ 如果事务失败，使用 Undo Log 恢复原状
└─ 这就是为什么 ROLLBACK 能撤销操作
```

### 2. 一致性（Consistency）

```
含义：事务执行前后，数据库都满足完整性约束

例子：
├─ 转账前：A=2000, B=1000, 总计=3000
├─ 转账后：A=1000, B=2000, 总计=3000
└─ 不管怎么转，总金额不变（守恒）

MySQL 实现方式：
├─ 通过约束（主键、外键、唯一性等）保证
├─ 通过触发器保证业务规则
└─ 本质上是原子性、隔离性、持久性共同保证的结果
```

### 3. 隔离性（Isolation）

```
含义：并发执行的事务之间互不影响

问题场景：
├─ 事务 A 正在修改数据
├─ 事务 B 同时也想读取/修改同一数据
└─ 如果不隔离，会出现各种问题

MySQL 实现方式：
├─ 通过锁机制（共享锁、排他锁等）
├─ 通过 MVCC（多版本并发控制）
└─ 提供多种隔离级别供选择
```

### 4. 持久性（Durability）

```
含义：事务一旦提交，结果永久保存

即使发生：
├─ 数据库崩溃
├─ 服务器断电
├─ 系统故障
└─ 已提交的数据也不会丢失

MySQL 实现方式：
├─ 通过 Redo Log（重做日志）实现
├─ 事务提交时，先写 Redo Log
├─ 即使崩溃，重启后也能通过 Redo Log 恢复
└─ 这就是 WAL（Write-Ahead Logging）策略
```

### ACID 实现机制总结

| 特性 | 实现机制 | 作用 |
|------|----------|------|
| **原子性** | Undo Log | 记录修改前的数据，支持回滚 |
| **一致性** | 约束 + 其他三个特性 | 保证数据满足完整性规则 |
| **隔离性** | 锁 + MVCC | 控制并发访问，防止相互干扰 |
| **持久性** | Redo Log | 保证提交的数据不丢失 |

---

## 事务隔离级别

### 为什么需要隔离级别？

```
理想情况：每个事务完全隔离，互不干扰
现实问题：完全隔离会导致性能极差（只能串行执行）

解决方案：提供多个"隔离级别"
├─ 隔离级别越高，并发问题越少，但性能越差
├─ 隔离级别越低，性能越好，但可能出现一些问题
└─ 根据业务需求选择合适的级别
```

### 并发事务可能出现的问题

#### 1. 脏读（Dirty Read）

```
定义：读取到其他事务未提交的数据

场景演示：
┌─────────────────────────────────────────────────────┐
│   时间轴    │     事务 A      │      事务 B         │
├─────────────┼─────────────────┼─────────────────────┤
│   T1        │ BEGIN           │                     │
│   T2        │ UPDATE          │                     │
│             │ SET balance=500 │                     │
│             │ (原值1000)      │                     │
│   T3        │                 │ BEGIN               │
│   T4        │                 │ SELECT balance      │
│             │                 │ → 读到 500 (脏数据) │
│   T5        │ ROLLBACK        │                     │
│             │ (回滚到1000)    │                     │
│   T6        │                 │ 使用 500 做业务判断 │
│             │                 │ → 出错！            │
└─────────────────────────────────────────────────────┘

问题：B 读到的 500 是 A 未提交的数据，A 回滚后这个数据就无效了
危害：基于无效数据做出的任何决策都是错误的
```

#### 2. 不可重复读（Non-Repeatable Read）

```
定义：同一事务中，两次读取同一数据得到不同结果

场景演示：
┌─────────────────────────────────────────────────────┐
│   时间轴    │     事务 A      │      事务 B         │
├─────────────┼─────────────────┼─────────────────────┤
│   T1        │ BEGIN           │                     │
│   T2        │ SELECT balance  │                     │
│             │ → 读到 1000     │                     │
│   T3        │                 │ BEGIN               │
│   T4        │                 │ UPDATE              │
│             │                 │ SET balance=500     │
│   T5        │                 │ COMMIT              │
│   T6        │ SELECT balance  │                     │
│             │ → 读到 500      │                     │
│             │ → 和 T2 不一样! │                     │
│   T7        │ COMMIT          │                     │
└─────────────────────────────────────────────────────┘

问题：A 在同一个事务中，两次读取同一数据却得到不同结果
危害：无法保证数据的一致性视图，业务逻辑可能出错
```

#### 3. 幻读（Phantom Read）

```
定义：同一事务中，两次查询返回的记录数不同（多了或少了行）

场景演示：
┌─────────────────────────────────────────────────────┐
│   时间轴    │     事务 A           │    事务 B      │
├─────────────┼──────────────────────┼────────────────┤
│   T1        │ BEGIN                │                │
│   T2        │ SELECT * FROM users  │                │
│             │ WHERE age > 20       │                │
│             │ → 返回 3 条记录      │                │
│   T3        │                      │ BEGIN          │
│   T4        │                      │ INSERT INTO    │
│             │                      │ users (age=25) │
│   T5        │                      │ COMMIT         │
│   T6        │ SELECT * FROM users  │                │
│             │ WHERE age > 20       │                │
│             │ → 返回 4 条记录      │                │
│             │ → 多了一条"幻影"!   │                │
│   T7        │ COMMIT               │                │
└─────────────────────────────────────────────────────┘

问题：A 的两次相同查询返回了不同数量的行
与不可重复读的区别：
├─ 不可重复读：同一行数据的值变了
└─ 幻读：符合条件的行数变了（新增或删除）
```

### 四种隔离级别

```
SQL 标准定义的四种隔离级别（从低到高）：

┌─────────────────────────────────────────────────────┐
│ 级别              │ 脏读 │ 不可重复读 │ 幻读 │ 性能 │
├───────────────────┼──────┼────────────┼──────┼──────┤
│ READ UNCOMMITTED  │  ✗   │     ✗      │  ✗   │ 最高 │
│ (读未提交)        │      │            │      │      │
├───────────────────┼──────┼────────────┼──────┼──────┤
│ READ COMMITTED    │  ✓   │     ✗      │  ✗   │ 较高 │
│ (读已提交)        │      │            │      │      │
├───────────────────┼──────┼────────────┼──────┼──────┤
│ REPEATABLE READ   │  ✓   │     ✓      │  ✗   │ 较低 │
│ (可重复读)        │      │            │      │      │
├───────────────────┼──────┼────────────┼──────┼──────┤
│ SERIALIZABLE      │  ✓   │     ✓      │  ✓   │ 最低 │
│ (串行化)          │      │            │      │      │
└─────────────────────────────────────────────────────┘

✓ = 解决了该问题
✗ = 可能存在该问题

MySQL InnoDB 默认级别：REPEATABLE READ（可重复读）
Oracle/SQL Server 默认：READ COMMITTED（读已提交）
```

### 隔离级别详解

#### 1. READ UNCOMMITTED（读未提交）

```
特点：
├─ 最低隔离级别，几乎没有隔离
├─ 事务可以读取其他事务未提交的数据
├─ 会出现脏读、不可重复读、幻读
└─ 几乎不在生产环境使用

使用场景：
├─ 对数据一致性要求极低的统计场景
└─ 纯只读的近似值查询

设置方式：
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

#### 2. READ COMMITTED（读已提交）

```
特点：
├─ 只能读取其他事务已提交的数据
├─ 解决了脏读问题
├─ 仍可能出现不可重复读、幻读
└─ Oracle 和 SQL Server 的默认级别

实现方式：
├─ 每次读取都生成新的快照
└─ 只读取最新已提交的数据版本

使用场景：
├─ 大多数 OLTP 应用
├─ 对性能要求较高
└─ 可以接受不可重复读

设置方式：
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

#### 3. REPEATABLE READ（可重复读）

```
特点：
├─ 同一事务中多次读取结果一致
├─ 解决了脏读和不可重复读
├─ MySQL InnoDB 的默认级别
└─ MySQL 通过 MVCC + 间隙锁基本解决了幻读

实现方式：
├─ 事务开始时创建一致性快照
├─ 整个事务期间使用同一快照
└─ 结合间隙锁防止幻读

使用场景：
├─ 需要一致性视图的业务
├─ 报表统计
└─ 需要多次读取同一数据的场景

设置方式：
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

#### 4. SERIALIZABLE（串行化）

```
特点：
├─ 最高隔离级别
├─ 事务完全串行执行
├─ 解决所有并发问题
└─ 性能最差

实现方式：
├─ 读操作加共享锁
├─ 写操作加排他锁
└─ 范围查询加范围锁

使用场景：
├─ 对数据一致性要求极高
├─ 并发量低的场景
└─ 金融核心系统的关键操作

设置方式：
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

### 查看和设置隔离级别

```sql
-- 查看当前会话隔离级别
SELECT @@transaction_isolation;

-- 查看全局隔离级别
SELECT @@global.transaction_isolation;

-- 设置当前会话隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 设置全局隔离级别（需要 SUPER 权限）
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 在配置文件中设置（my.cnf）
[mysqld]
transaction-isolation = READ-COMMITTED
```

---

## MySQL 如何实现隔离级别

### InnoDB 的核心机制

```
MySQL InnoDB 实现隔离级别主要依靠两大机制：

┌─────────────────────────────────────────────────────┐
│                                                      │
│   1. MVCC（多版本并发控制）                          │
│      └─ 用于实现一致性读（非阻塞读）                 │
│      └─ 读操作不加锁，读写不冲突                     │
│                                                      │
│   2. 锁机制                                          │
│      └─ 用于实现当前读（加锁读）                     │
│      └─ 防止写写冲突                                 │
│      └─ 配合 MVCC 防止幻读                           │
│                                                      │
└─────────────────────────────────────────────────────┘
```

### 各隔离级别的实现方式

```
┌─────────────────────────────────────────────────────────────────┐
│  隔离级别          │        实现机制                            │
├────────────────────┼────────────────────────────────────────────┤
│  READ UNCOMMITTED  │ 直接读取最新数据，不使用 MVCC              │
│                    │ 不加任何锁（读操作）                        │
├────────────────────┼────────────────────────────────────────────┤
│  READ COMMITTED    │ MVCC：每次读取生成新的 Read View           │
│                    │ 只能看到已提交事务的修改                   │
├────────────────────┼────────────────────────────────────────────┤
│  REPEATABLE READ   │ MVCC：事务开始时生成 Read View，全程使用   │
│                    │ 间隙锁（Gap Lock）防止幻读                 │
├────────────────────┼────────────────────────────────────────────┤
│  SERIALIZABLE      │ 所有读操作加共享锁                         │
│                    │ 所有写操作加排他锁                         │
│                    │ 本质上是串行执行                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## MVCC 多版本并发控制

### 什么是 MVCC？

```
MVCC = Multi-Version Concurrency Control（多版本并发控制）

核心思想：
├─ 为每条数据保存多个版本
├─ 读操作读取某个时刻的快照版本
├─ 写操作创建新版本
└─ 读写操作互不阻塞

好处：
├─ 读不阻塞写，写不阻塞读
├─ 大大提高了并发性能
└─ 实现了非阻塞的一致性读
```

### MVCC 的实现原理

#### 隐藏列

```
InnoDB 为每行数据添加三个隐藏列：

┌─────────────────────────────────────────────────────┐
│ 用户数据列      │ DB_TRX_ID │ DB_ROLL_PTR │ DB_ROW_ID │
├─────────────────┼───────────┼─────────────┼───────────┤
│ id=1, name=Tom  │ 100       │ 0x12345     │ 1         │
└─────────────────────────────────────────────────────┘

DB_TRX_ID (6字节)：
├─ 最近修改该行的事务 ID
└─ 每次修改都会更新

DB_ROLL_PTR (7字节)：
├─ 回滚指针
├─ 指向该行的上一个版本（存在 Undo Log 中）
└─ 形成版本链

DB_ROW_ID (6字节)：
├─ 行 ID
├─ 如果表没有主键，InnoDB 自动生成
└─ 用于构建聚簇索引
```

#### Undo Log 版本链

```
当数据被修改时，旧版本会被保存到 Undo Log 中：

事务 100 将 name 从 'Tom' 改为 'Jerry'
事务 200 将 name 从 'Jerry' 改为 'Mike'

版本链示意：

当前行数据：
┌────────────────────────────────────────┐
│ id=1, name=Mike │ trx_id=200 │ roll_ptr │
└────────────────────────────────────────┘
                                    │
                                    ↓
Undo Log:                  ┌────────────────────────────────────────┐
                           │ id=1, name=Jerry │ trx_id=100 │ roll_ptr │
                           └────────────────────────────────────────┘
                                                                │
                                                                ↓
                                              ┌────────────────────────────────────────┐
                                              │ id=1, name=Tom │ trx_id=50 │ null       │
                                              └────────────────────────────────────────┘

通过 roll_ptr 可以找到该行数据的所有历史版本！
```

#### Read View（读视图）

```
Read View 是 MVCC 的核心，用于判断哪些版本对当前事务可见

Read View 包含的信息：
┌─────────────────────────────────────────────────────┐
│ m_ids        │ 创建 Read View 时活跃的事务 ID 列表  │
│ min_trx_id   │ m_ids 中的最小值                     │
│ max_trx_id   │ 创建 Read View 时系统分配的下一个    │
│              │ 事务 ID（即当前最大事务 ID + 1）     │
│ creator_trx_id │ 创建该 Read View 的事务 ID        │
└─────────────────────────────────────────────────────┘
```

#### 可见性判断算法

```
判断某个数据版本是否对当前事务可见：

┌─────────────────────────────────────────────────────┐
│                                                      │
│  版本的 trx_id == creator_trx_id ?                  │
│       │                                              │
│       ├─ 是 → 可见（自己修改的）                    │
│       │                                              │
│       └─ 否 → 继续判断                               │
│                  │                                   │
│  trx_id < min_trx_id ?                              │
│       │                                              │
│       ├─ 是 → 可见（事务已提交）                    │
│       │                                              │
│       └─ 否 → 继续判断                               │
│                  │                                   │
│  trx_id >= max_trx_id ?                             │
│       │                                              │
│       ├─ 是 → 不可见（事务在 RV 创建后才开始）      │
│       │                                              │
│       └─ 否 → 继续判断                               │
│                  │                                   │
│  trx_id 在 m_ids 中 ?                               │
│       │                                              │
│       ├─ 是 → 不可见（事务还未提交）                │
│       │                                              │
│       └─ 否 → 可见（事务已提交）                    │
│                                                      │
└─────────────────────────────────────────────────────┘

如果当前版本不可见，通过 roll_ptr 找到上一个版本继续判断
直到找到可见的版本或者版本链结束
```

### Read View 创建时机

```
不同隔离级别创建 Read View 的时机不同：

┌─────────────────────────────────────────────────────┐
│                                                      │
│  READ COMMITTED（读已提交）:                         │
│  └─ 每次 SELECT 都创建新的 Read View               │
│  └─ 所以每次都能看到最新已提交的数据                │
│  └─ 导致"不可重复读"                               │
│                                                      │
│  REPEATABLE READ（可重复读）:                        │
│  └─ 第一次 SELECT 时创建 Read View                 │
│  └─ 整个事务期间使用同一个 Read View               │
│  └─ 所以多次读取结果一致                            │
│  └─ 实现了"可重复读"                               │
│                                                      │
└─────────────────────────────────────────────────────┘
```

### MVCC 示例详解

```
假设有一张表 users，初始数据：id=1, name='Tom'
当前最大事务 ID 为 50

┌─────────────────────────────────────────────────────────────────┐
│   时间   │     事务 A (id=100)    │     事务 B (id=200)         │
├──────────┼────────────────────────┼─────────────────────────────┤
│   T1     │ BEGIN                  │                             │
│   T2     │ SELECT name            │                             │
│          │ 创建 Read View:        │                             │
│          │ m_ids=[], min=100,     │                             │
│          │ max=101, creator=100   │                             │
│          │ → 返回 'Tom'           │                             │
│   T3     │                        │ BEGIN                       │
│   T4     │                        │ UPDATE name='Jerry'         │
│          │                        │ (行 trx_id 变为 200)        │
│   T5     │                        │ COMMIT                      │
│   T6     │ SELECT name            │                             │
│          │ (RR: 使用原 RV)        │                             │
│          │ 行 trx_id=200 >= 101   │                             │
│          │ → 不可见，找旧版本     │                             │
│          │ → 返回 'Tom'           │                             │
│          │                        │                             │
│          │ (RC: 新建 RV)          │                             │
│          │ m_ids=[], min=201      │                             │
│          │ 200 < 201              │                             │
│          │ → 可见                 │                             │
│          │ → 返回 'Jerry'         │                             │
│   T7     │ COMMIT                 │                             │
└─────────────────────────────────────────────────────────────────┘

这个例子清楚展示了 RC 和 RR 在 Read View 创建时机上的区别
```

### 快照读 vs 当前读

```
InnoDB 中有两种读取方式：

┌─────────────────────────────────────────────────────┐
│                                                      │
│  快照读（Snapshot Read）:                            │
│  ├─ 读取 MVCC 版本链中的某个快照版本                │
│  ├─ 不加锁，非阻塞                                  │
│  ├─ 普通 SELECT 语句                                │
│  └─ SELECT * FROM table WHERE ...                   │
│                                                      │
│  当前读（Current Read）:                             │
│  ├─ 读取数据的最新版本                              │
│  ├─ 会加锁（共享锁或排他锁）                        │
│  ├─ 以下语句触发当前读：                            │
│  │   ├─ SELECT ... FOR UPDATE     （加排他锁）      │
│  │   ├─ SELECT ... FOR SHARE      （加共享锁）      │
│  │   ├─ SELECT ... LOCK IN SHARE MODE               │
│  │   ├─ INSERT                                      │
│  │   ├─ UPDATE                                      │
│  │   └─ DELETE                                      │
│                                                      │
└─────────────────────────────────────────────────────┘

重要理解：
├─ MVCC 只对快照读有效
├─ 当前读绕过 MVCC，直接读最新数据
└─ 这就是为什么在 RR 级别下 UPDATE 能看到其他事务的修改
```

---

## 锁机制详解

### 为什么需要锁？

```
MVCC 解决了读写冲突，但无法解决写写冲突

场景：
├─ 事务 A 要修改行 X
├─ 事务 B 也要修改行 X
└─ 如果同时修改，会导致数据不一致

解决方案：使用锁来控制写操作的并发
```

### 锁的分类

#### 按粒度分类

```
┌─────────────────────────────────────────────────────┐
│                                                      │
│  表锁（Table Lock）:                                 │
│  ├─ 锁定整张表                                      │
│  ├─ 开销小，加锁快                                  │
│  ├─ 并发度低                                        │
│  └─ MyISAM 和 InnoDB 都支持                         │
│                                                      │
│  行锁（Row Lock）:                                   │
│  ├─ 只锁定需要的行                                  │
│  ├─ 开销大，加锁慢                                  │
│  ├─ 并发度高                                        │
│  └─ 只有 InnoDB 支持                                │
│                                                      │
│  页锁（Page Lock）:                                  │
│  ├─ 锁定数据页（介于表锁和行锁之间）                │
│  └─ BDB 引擎支持（已废弃）                          │
│                                                      │
└─────────────────────────────────────────────────────┘
```

#### 按模式分类

```
┌─────────────────────────────────────────────────────┐
│                                                      │
│  共享锁（S Lock / Shared Lock）:                    │
│  ├─ 也叫读锁                                        │
│  ├─ 多个事务可以同时持有同一资源的共享锁            │
│  ├─ 持有共享锁时，其他事务不能修改数据              │
│  └─ SELECT ... FOR SHARE / LOCK IN SHARE MODE      │
│                                                      │
│  排他锁（X Lock / Exclusive Lock）:                 │
│  ├─ 也叫写锁                                        │
│  ├─ 同一时间只能有一个事务持有                      │
│  ├─ 持有排他锁时，其他事务不能读也不能写            │
│  └─ SELECT ... FOR UPDATE / INSERT / UPDATE / DELETE │
│                                                      │
└─────────────────────────────────────────────────────┘

兼容性矩阵：
┌───────────┬─────────┬─────────┐
│           │    S    │    X    │
├───────────┼─────────┼─────────┤
│     S     │   兼容   │  不兼容  │
├───────────┼─────────┼─────────┤
│     X     │  不兼容  │  不兼容  │
└───────────┴─────────┴─────────┘
```

### InnoDB 行锁的类型

#### 1. 记录锁（Record Lock）

```
定义：锁定索引记录

示例：
SELECT * FROM users WHERE id = 1 FOR UPDATE;

效果：
├─ 锁定 id=1 这条记录
├─ 其他事务不能修改或删除这条记录
└─ 其他事务可以操作其他记录

特点：
└─ 必须通过索引条件定位到具体记录
```

#### 2. 间隙锁（Gap Lock）

```
定义：锁定索引记录之间的间隙，不包含记录本身

目的：防止幻读（阻止其他事务在间隙中插入数据）

示例：
表中有 id = 1, 5, 10 三条记录

SELECT * FROM users WHERE id > 5 AND id < 10 FOR UPDATE;

锁定的范围：(5, 10) 这个间隙
├─ 5 和 10 本身不被锁定
├─ 其他事务不能在这个间隙插入数据
└─ 比如不能插入 id=6, 7, 8, 9

间隙示意：
┌─────┬─────────┬─────────┬─────────┬─────────┐
│ ... │ (1,5)   │ id=5    │ (5,10)  │ id=10   │
│     │ 间隙    │ 记录    │ 间隙    │ 记录    │
└─────┴─────────┴─────────┴─────────┴─────────┘

重要：
├─ 间隙锁只在 REPEATABLE READ 级别下存在
├─ READ COMMITTED 级别没有间隙锁
└─ 间隙锁之间不冲突（都是为了阻止插入）
```

#### 3. 临键锁（Next-Key Lock）

```
定义：记录锁 + 间隙锁的组合，锁定记录及其前面的间隙

公式：Next-Key Lock = Record Lock + Gap Lock

示例：
表中有 id = 1, 5, 10 三条记录

SELECT * FROM users WHERE id = 5 FOR UPDATE;

锁定范围：(1, 5]
├─ 包含 id=5 这条记录（记录锁）
├─ 包含 (1, 5) 这个间隙（间隙锁）
└─ 左开右闭区间

为什么需要临键锁？
├─ 仅用记录锁：无法防止在间隙插入数据（幻读）
├─ 仅用间隙锁：无法锁定记录本身
└─ 临键锁两者兼顾，是 InnoDB 的默认行锁类型
```

#### 4. 插入意向锁（Insert Intention Lock）

```
定义：INSERT 操作在插入行之前需要获取的间隙锁

特点：
├─ 是一种特殊的间隙锁
├─ 表示有插入数据的意向
├─ 多个插入意向锁之间不冲突
└─ 与间隙锁冲突（被阻塞）

示例：
事务 A 对 (5, 10) 加了间隙锁
事务 B 想插入 id=7

事务 B 会先尝试获取 (5, 10) 的插入意向锁
但因为事务 A 的间隙锁，事务 B 会被阻塞

好处：
└─ 允许多个事务在同一个间隙的不同位置插入数据
```

### 锁的算法示例

```sql
-- 假设表 users 有 id 列（主键），数据为 1, 5, 10, 15

-- 示例1：等值查询，记录存在
SELECT * FROM users WHERE id = 5 FOR UPDATE;
-- 加的锁：记录锁，只锁 id=5
-- 说明：主键/唯一索引的等值查询命中记录时，可降级为记录锁
--       不需要锁前后间隙，因为不会出现新行“插入后变成命中”的幻读

-- 示例2：等值查询，记录不存在
SELECT * FROM users WHERE id = 8 FOR UPDATE;
-- 加的锁：间隙锁，锁 (5, 10)

-- 示例3：范围查询
SELECT * FROM users WHERE id > 5 AND id < 10 FOR UPDATE;
-- 加的锁：间隙锁 (5, 10)

-- 示例4：范围查询（包含边界）
SELECT * FROM users WHERE id >= 5 AND id <= 10 FOR UPDATE;
-- 加的锁：临键锁 (1, 5] + 临键锁 (5, 10]

-- 示例5：全表扫描
SELECT * FROM users WHERE name = 'Tom' FOR UPDATE;
-- 如果 name 没有索引，会锁整个表！
-- 所以 WHERE 条件一定要走索引
```

### FOR SHARE 在 RR 下是否会产生间隙锁

```
结论：
├─ FOR SHARE 是当前读，和 FOR UPDATE 一样会加行锁
├─ 在 RR 下会根据条件加间隙锁或临键锁
└─ 只有唯一索引等值命中时，才会降级为记录锁

示例：唯一索引等值命中（无间隙锁）
SELECT * FROM users WHERE id = 5 FOR SHARE;
-- 加的锁：记录锁（S），只锁 id=5

示例：唯一索引等值未命中（间隙锁）
SELECT * FROM users WHERE id = 8 FOR SHARE;
-- 加的锁：间隙锁，锁 (5, 10)

示例：范围查询（临键锁）
SELECT * FROM users WHERE id >= 5 AND id <= 10 FOR SHARE;
-- 加的锁：临键锁 (1, 5] + 临键锁 (5, 10]
```

### RR 下当前读是否会出现幻读

```
结论：
└─ InnoDB 在 RR 下的当前读会用临键锁阻止插入
   因此锁定读本身不会出现幻读

阻止幻读的示例：
事务 A（RR）:
SELECT * FROM users WHERE id BETWEEN 5 AND 10 FOR SHARE;
-- 对 (1, 5] 和 (5, 10] 加临键锁

事务 B:
INSERT INTO users(id) VALUES (7);
-- 被阻塞，直到事务 A 提交或回滚
```

### RR 下的特殊幻读场景（先快照读，后更新）

```
说明：
└─ RR + MVCC 能保证快照读一致
   但当同一事务之后执行当前读（如 UPDATE）时
   可能“看到”之前快照中不存在的记录

示例：
┌─────────────────────────────────────────────────────┐
│   时间   │     事务 A            │    事务 B        │
├──────────┼───────────────────────┼──────────────────┤
│   T1     │ BEGIN                 │ BEGIN            │
│   T2     │ SELECT * FROM t       │                  │
│          │ WHERE id = 5; (空)    │                  │
│          │ -- 快照读：A 看到 5 不存在 │              │
│   T3     │                       │ INSERT INTO t(id)│
│          │                       │ VALUES (5);      │
│   T4     │                       │ COMMIT           │
│          │                       │ -- B 提交后已有 5 │
│   T5     │ UPDATE t SET col='x'  │                  │
│          │ WHERE id = 5;         │                  │
│          │ -- 当前读：A 尝试更新这条记录 │          │
│   T6     │ SELECT * FROM t       │                  │
│          │ WHERE id = 5; (有数据)│                  │
│          │ -- 出现“幻影”           │                │
└─────────────────────────────────────────────────────┘

结论：
└─ RR 不能完全避免幻读
   该场景发生在同一事务内先快照读
   后通过当前读/更新“看到”新插入的记录
```

### 意向锁（Intention Lock）

```
定义：表级锁，表示事务想要在表中的某些行上加行锁

类型：
├─ 意向共享锁（IS）：事务想获取某行的共享锁
└─ 意向排他锁（IX）：事务想获取某行的排他锁

作用：
├─ 快速判断表中是否有行被锁定
├─ 避免逐行检查是否有锁
└─ 加快表锁的获取速度

兼容性矩阵：
┌───────────┬─────┬─────┬─────┬─────┐
│           │  IS │  IX │  S  │  X  │
├───────────┼─────┼─────┼─────┼─────┤
│    IS     │  ✓  │  ✓  │  ✓  │  ✗  │
├───────────┼─────┼─────┼─────┼─────┤
│    IX     │  ✓  │  ✓  │  ✗  │  ✗  │
├───────────┼─────┼─────┼─────┼─────┤
│    S      │  ✓  │  ✗  │  ✓  │  ✗  │
├───────────┼─────┼─────┼─────┼─────┤
│    X      │  ✗  │  ✗  │  ✗  │  ✗  │
└───────────┴─────┴─────┴─────┴─────┘
```

### 死锁

```
定义：两个或多个事务互相持有对方需要的锁，形成循环等待

示例：
┌─────────────────────────────────────────────────────┐
│   时间   │     事务 A            │    事务 B        │
├──────────┼───────────────────────┼──────────────────┤
│   T1     │ BEGIN                 │ BEGIN            │
│   T2     │ UPDATE ... WHERE id=1 │                  │
│          │ (获取 id=1 的 X 锁)   │                  │
│   T3     │                       │ UPDATE ... id=2  │
│          │                       │ (获取 id=2 的锁) │
│   T4     │ UPDATE ... WHERE id=2 │                  │
│          │ (等待 B 释放 id=2)    │                  │
│   T5     │                       │ UPDATE ... id=1  │
│          │                       │ (等待 A 释放 id=1)│
│          │                       │                  │
│          │ ← 死锁！互相等待 →    │                  │
└─────────────────────────────────────────────────────┘

InnoDB 死锁检测：
├─ 自动检测死锁（wait-for graph）
├─ 选择一个事务作为牺牲者（victim）回滚
├─ 通常选择 undo log 较小的事务
└─ 被回滚的事务需要重试
```

#### 避免死锁的方法

```sql
1. 按固定顺序访问资源
   -- 所有事务都按 id 从小到大的顺序更新
   -- 这样就不会形成循环等待

2. 尽量使用低隔离级别
   -- READ COMMITTED 没有间隙锁
   -- 减少锁的范围和数量

3. 大事务拆分为小事务
   -- 减少锁持有时间
   -- 降低死锁概率

4. 为表添加合适的索引
   -- 避免全表扫描导致的表锁
   -- 减少锁的范围

5. 使用 SELECT ... FOR UPDATE NOWAIT
   -- 如果无法获取锁，立即返回错误
   -- 而不是等待（适用于 MySQL 8.0+）
   SELECT * FROM users WHERE id = 1 FOR UPDATE NOWAIT;

6. 设置合理的锁等待超时
   SET innodb_lock_wait_timeout = 5;  -- 5秒超时
```

---

## 高并发下的可见性问题

### 问题分类与解决方案

```
┌─────────────────────────────────────────────────────┐
│  问题类型      │    原因          │    解决方案     │
├────────────────┼──────────────────┼─────────────────┤
│  脏读          │ 读到未提交数据   │ RC 及以上级别   │
├────────────────┼──────────────────┼─────────────────┤
│  不可重复读    │ 两次读取不一致   │ RR 级别 + MVCC  │
├────────────────┼──────────────────┼─────────────────┤
│  幻读          │ 范围查询行数变化 │ RR + 间隙锁     │
├────────────────┼──────────────────┼─────────────────┤
│  丢失更新      │ 并发更新覆盖     │ 悲观锁/乐观锁   │
├────────────────┼──────────────────┼─────────────────┤
│  写偏斜        │ 基于旧快照更新   │ SELECT FOR UPDATE │
└─────────────────────────────────────────────────────┘
```

### 丢失更新问题

```
场景：两个事务同时读取同一数据并更新

示例 - 库存扣减：
初始库存：stock = 10

┌─────────────────────────────────────────────────────┐
│   时间   │     事务 A            │    事务 B        │
├──────────┼───────────────────────┼──────────────────┤
│   T1     │ BEGIN                 │ BEGIN            │
│   T2     │ SELECT stock          │                  │
│          │ → 读到 10             │                  │
│   T3     │                       │ SELECT stock     │
│          │                       │ → 读到 10        │
│   T4     │ stock = 10 - 1 = 9    │                  │
│   T5     │ UPDATE SET stock=9    │                  │
│   T6     │ COMMIT                │                  │
│   T7     │                       │ stock = 10 - 1   │
│          │                       │ = 9              │
│   T8     │                       │ UPDATE stock=9   │
│   T9     │                       │ COMMIT           │
└─────────────────────────────────────────────────────┘

结果：stock = 9，但实际应该是 8
问题：A 的更新被 B 覆盖了
```

#### 解决方案一：悲观锁

```sql
-- 使用 SELECT ... FOR UPDATE 加排他锁
BEGIN;
SELECT stock FROM products WHERE id = 1 FOR UPDATE;  -- 加锁
-- 此时其他事务的 SELECT FOR UPDATE 会被阻塞
IF (stock >= 1) THEN
    UPDATE products SET stock = stock - 1 WHERE id = 1;
END IF;
COMMIT;

-- 或者直接在 UPDATE 中做判断
UPDATE products
SET stock = stock - 1
WHERE id = 1 AND stock >= 1;  -- 原子操作

-- 检查受影响行数
IF (affected_rows == 0) THEN
    -- 库存不足，提示用户
END IF;
```

#### 解决方案二：乐观锁

```sql
-- 方式1：使用版本号
-- 表结构增加 version 字段
ALTER TABLE products ADD COLUMN version INT DEFAULT 0;

-- 更新时检查版本号
BEGIN;
SELECT stock, version FROM products WHERE id = 1;
-- 假设读到 stock=10, version=5

UPDATE products
SET stock = stock - 1, version = version + 1
WHERE id = 1 AND version = 5;  -- 版本号必须匹配

IF (affected_rows == 0) THEN
    -- 说明其他事务已经修改过了，需要重试
    ROLLBACK;
    -- 重新执行
END IF;
COMMIT;

-- 方式2：使用时间戳
UPDATE products
SET stock = stock - 1, update_time = NOW()
WHERE id = 1 AND update_time = '2024-01-01 12:00:00';
```

### 写偏斜问题（Write Skew）

```
场景：基于过时的快照数据做出更新决策

示例 - 值班约束（至少一人值班）：
初始状态：Alice 和 Bob 都在值班

┌─────────────────────────────────────────────────────┐
│   时间   │     事务 A (Alice)    │  事务 B (Bob)    │
├──────────┼───────────────────────┼──────────────────┤
│   T1     │ BEGIN                 │ BEGIN            │
│   T2     │ SELECT COUNT(*)       │                  │
│          │ WHERE on_call=true    │                  │
│          │ → 2 (≥1, 可以离开)   │                  │
│   T3     │                       │ SELECT COUNT(*)  │
│          │                       │ → 2 (≥1, 可以)  │
│   T4     │ UPDATE SET            │                  │
│          │ on_call=false         │                  │
│          │ WHERE name='Alice'    │                  │
│   T5     │                       │ UPDATE SET       │
│          │                       │ on_call=false    │
│          │                       │ WHERE name='Bob' │
│   T6     │ COMMIT                │                  │
│   T7     │                       │ COMMIT           │
└─────────────────────────────────────────────────────┘

结果：没有人值班了！
问题：两个事务都基于过时的快照（2人值班）做决策
```

#### 解决方案

```sql
-- 方案1：SELECT FOR UPDATE
BEGIN;
SELECT * FROM doctors
WHERE on_call = true
FOR UPDATE;  -- 锁定所有值班记录

-- 现在可以安全检查
IF (COUNT(*) >= 2) THEN
    UPDATE doctors SET on_call = false WHERE name = 'Alice';
END IF;
COMMIT;

-- 方案2：使用 SERIALIZABLE 隔离级别
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN;
-- 自动加锁
SELECT COUNT(*) FROM doctors WHERE on_call = true;
-- ...
COMMIT;
```

### MySQL RR 级别下的幻读问题

```
重要理解：MySQL 的 RR 级别并不能完全防止幻读

┌─────────────────────────────────────────────────────┐
│                                                      │
│  快照读（普通 SELECT）:                              │
│  └─ 通过 MVCC 解决了幻读                            │
│  └─ 多次读取结果一致                                │
│                                                      │
│  当前读（SELECT FOR UPDATE、UPDATE、DELETE）:        │
│  └─ 读取最新数据，可能出现幻读                      │
│  └─ 需要依靠间隙锁来防止                            │
│                                                      │
└─────────────────────────────────────────────────────┘

示例：RR 级别下的幻读场景
```

```sql
-- 初始数据：users 表中没有 id=5 的记录

-- 事务 A
BEGIN;
SELECT * FROM users WHERE id = 5;  -- 快照读，返回空
-- ... 做一些其他操作 ...
SELECT * FROM users WHERE id = 5 FOR UPDATE;  -- 当前读
-- 如果此时事务 B 已经插入了 id=5，这里就能看到！
-- 这就是幻读

-- 事务 B（在事务 A 的两次查询之间）
BEGIN;
INSERT INTO users (id, name) VALUES (5, 'Tom');
COMMIT;
```

#### 正确的防止幻读方式

```sql
-- 方法1：第一次查询就使用当前读
BEGIN;
SELECT * FROM users WHERE id = 5 FOR UPDATE;  -- 加间隙锁
-- 阻止其他事务插入 id=5 的记录
-- ...
COMMIT;

-- 方法2：使用唯一索引
-- 如果 id 是唯一索引，插入相同值会被阻塞或失败
```

---

## 实战与最佳实践

### 选择合适的隔离级别

```
┌─────────────────────────────────────────────────────┐
│  场景                      │   推荐隔离级别         │
├────────────────────────────┼────────────────────────┤
│  电商订单/库存             │  RC + 乐观锁           │
│  金融转账                  │  RR + SELECT FOR UPDATE│
│  报表统计                  │  RR（一致性快照）      │
│  日志记录                  │  RC（高性能）          │
│  银行核心系统              │  SERIALIZABLE          │
└─────────────────────────────────────────────────────┘

多数互联网公司使用 READ COMMITTED 的原因：
├─ 性能更好（没有间隙锁）
├─ 死锁概率更低
├─ 通过应用层乐观锁解决并发问题
└─ RR 的一致性视图不是刚需
```

### 常见业务场景解决方案

#### 场景1：秒杀/库存扣减

```sql
-- 方案1：悲观锁（适合竞争激烈的场景）
BEGIN;
SELECT stock FROM products WHERE id = 1 FOR UPDATE;
IF (stock > 0) THEN
    UPDATE products SET stock = stock - 1 WHERE id = 1;
    INSERT INTO orders (...) VALUES (...);
END IF;
COMMIT;

-- 方案2：乐观锁（适合竞争不激烈的场景）
-- 直接更新，利用数据库的原子性
UPDATE products
SET stock = stock - 1
WHERE id = 1 AND stock > 0;

IF (affected_rows > 0) THEN
    INSERT INTO orders (...) VALUES (...);
ELSE
    -- 库存不足
END IF;

-- 方案3：Redis 预扣减（适合超高并发）
-- 1. 先在 Redis 中扣减库存（原子操作）
-- 2. 成功后异步写入数据库
-- 3. 定期同步 Redis 和数据库
```

#### 场景2：账户余额扣减

```sql
-- 防止超扣：在 UPDATE 中加入条件判断
UPDATE accounts
SET balance = balance - 100
WHERE id = 1 AND balance >= 100;

IF (affected_rows == 0) THEN
    -- 余额不足或账户不存在
    ROLLBACK;
END IF;

-- 使用悲观锁（确保一致性）
BEGIN;
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;
IF (balance >= 100) THEN
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
END IF;
COMMIT;
```

#### 场景3：订单状态流转

```sql
-- 状态机：确保状态按规则流转
-- 0=待支付, 1=已支付, 2=已发货, 3=已完成, 4=已取消

-- 支付订单：只有待支付状态才能支付
UPDATE orders
SET status = 1, pay_time = NOW()
WHERE id = 123 AND status = 0;

IF (affected_rows == 0) THEN
    -- 状态不对，可能已支付或已取消
END IF;

-- 使用乐观锁（版本号）
UPDATE orders
SET status = 1, version = version + 1
WHERE id = 123 AND status = 0 AND version = 5;
```

### 性能优化建议

```
┌─────────────────────────────────────────────────────┐
│                                                      │
│  1. 控制事务大小                                    │
│     ├─ 避免大事务，拆分为小事务                     │
│     ├─ 减少锁持有时间                               │
│     └─ 及时 COMMIT 或 ROLLBACK                      │
│                                                      │
│  2. 优化索引                                        │
│     ├─ WHERE 条件必须走索引                         │
│     ├─ 避免全表扫描导致的表锁                       │
│     └─ 使用覆盖索引减少回表                         │
│                                                      │
│  3. 减少锁竞争                                      │
│     ├─ 读写分离（读走从库）                         │
│     ├─ 分库分表（数据分片）                         │
│     └─ 使用队列串行化热点操作                       │
│                                                      │
│  4. 监控和告警                                      │
│     ├─ 监控慢查询日志                               │
│     ├─ 监控锁等待情况                               │
│     └─ 设置合理的超时时间                           │
│                                                      │
└─────────────────────────────────────────────────────┘
```

### 监控锁状态

```sql
-- 查看当前锁等待情况
SELECT * FROM information_schema.INNODB_LOCKS;

-- 查看锁等待关系
SELECT * FROM information_schema.INNODB_LOCK_WAITS;

-- 查看事务状态
SELECT * FROM information_schema.INNODB_TRX;

-- MySQL 8.0+ 使用 performance_schema
SELECT * FROM performance_schema.data_locks;
SELECT * FROM performance_schema.data_lock_waits;

-- 查看死锁日志
SHOW ENGINE INNODB STATUS;
```

---

## 常见问题解答

### Q1: 为什么互联网公司普遍使用 READ COMMITTED？

```
原因分析：

1. 性能考虑
   ├─ RC 没有间隙锁，锁冲突更少
   ├─ 死锁概率更低
   └─ 并发性能更好

2. 业务特点
   ├─ 互联网业务多为 OLTP（短事务）
   ├─ 对一致性快照需求不强
   └─ 通过应用层解决并发问题（乐观锁）

3. 可控性
   ├─ RC 的行为更可预测
   ├─ 问题更容易排查
   └─ 开发人员更容易理解

4. Oracle 迁移
   └─ 很多公司从 Oracle 迁移而来，Oracle 默认 RC

实际选择：
├─ 阿里巴巴：默认 RC
├─ 美团：默认 RC
└─ 大多数互联网公司：RC
```

### Q2: MVCC 能完全替代锁吗？

```
不能！MVCC 和锁是互补关系：

MVCC 的作用：
├─ 解决读写冲突（读不阻塞写）
├─ 实现一致性快照读
└─ 提高并发读性能

锁的作用：
├─ 解决写写冲突
├─ 实现当前读的隔离
└─ 防止幻读（间隙锁）

两者配合：
├─ 快照读用 MVCC
├─ 当前读用锁
└─ 共同实现完整的事务隔离
```

### Q3: 什么情况下会锁表？

```
InnoDB 可能锁表的情况：

1. UPDATE/DELETE 没有使用索引
   UPDATE users SET name='test' WHERE age=20;
   -- 如果 age 没有索引，会锁全表

2. 索引失效
   WHERE name LIKE '%test%'  -- 前缀模糊查询
   WHERE YEAR(create_time) = 2024  -- 函数导致索引失效

3. 显式表锁
   LOCK TABLES users WRITE;

4. DDL 操作
   ALTER TABLE users ADD COLUMN ...
   -- 会获取元数据锁（MDL）

如何避免：
├─ 确保 WHERE 条件走索引
├─ 使用 EXPLAIN 检查执行计划
├─ 避免大范围的 UPDATE/DELETE
└─ 分批处理大量数据操作
```

### Q4: 如何处理长事务？

```
长事务的危害：
├─ 占用锁资源，阻塞其他事务
├─ 占用 Undo Log 空间
├─ 影响 MVCC 的版本清理
└─ 增加主从延迟

解决方案：

1. 监控长事务
   SELECT * FROM information_schema.INNODB_TRX
   WHERE TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) > 60;

2. 设置超时
   SET GLOBAL innodb_lock_wait_timeout = 10;  -- 锁等待超时
   SET GLOBAL wait_timeout = 28800;  -- 连接超时

3. 拆分大事务
   -- 不好的做法
   BEGIN;
   UPDATE large_table SET ...;  -- 更新100万行
   COMMIT;

   -- 好的做法
   WHILE (有数据) DO
       BEGIN;
       UPDATE large_table SET ... LIMIT 1000;
       COMMIT;
       SLEEP(0.1);  -- 给其他事务机会
   END WHILE;

4. 及时提交
   -- 不好的做法
   BEGIN;
   SELECT ...;  -- 查询数据
   -- 业务处理（可能很久）
   UPDATE ...;
   COMMIT;

   -- 好的做法
   SELECT ...;  -- 在事务外查询
   -- 业务处理
   BEGIN;
   UPDATE ...;  -- 只在事务中做写操作
   COMMIT;
```

### Q5: 乐观锁和悲观锁如何选择？

```
┌─────────────────────────────────────────────────────┐
│                悲观锁                               │
├─────────────────────────────────────────────────────┤
│ 适用场景：                                          │
│ ├─ 写操作频繁                                       │
│ ├─ 冲突概率高                                       │
│ ├─ 响应时间要求不严格                               │
│ └─ 数据一致性要求高                                 │
│                                                      │
│ 实现方式：                                          │
│ └─ SELECT ... FOR UPDATE                            │
│                                                      │
│ 缺点：                                              │
│ ├─ 可能导致锁等待                                   │
│ ├─ 可能导致死锁                                     │
│ └─ 降低并发性能                                     │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│                乐观锁                               │
├─────────────────────────────────────────────────────┤
│ 适用场景：                                          │
│ ├─ 读操作频繁                                       │
│ ├─ 冲突概率低                                       │
│ ├─ 响应时间要求高                                   │
│ └─ 可以接受重试                                     │
│                                                      │
│ 实现方式：                                          │
│ ├─ 版本号                                           │
│ └─ CAS 更新                                         │
│                                                      │
│ 缺点：                                              │
│ ├─ 冲突时需要重试                                   │
│ ├─ 高并发下重试次数可能很多                         │
│ └─ 需要应用层配合                                   │
└─────────────────────────────────────────────────────┘

选择建议：
├─ 低冲突场景：乐观锁（更好的性能）
├─ 高冲突场景：悲观锁（避免大量重试）
└─ 混合使用：先乐观锁，重试N次后改悲观锁
```

---

## 附录：核心概念速查表

---

## 间隙锁与临键锁要点补充

### 结论速答

- 间隙锁主要在 REPEATABLE READ 下出现：InnoDB 默认使用临键锁防幻读。
- READ COMMITTED 一般不加间隙锁：只使用记录锁，但在外键检查或唯一性检查时可能出现间隙锁。
- 间隙锁是自动加的：由 InnoDB 在索引范围扫描或锁定读中自动加锁。

### 间隙锁如何自动加

- 触发场景：锁定读或写操作涉及范围条件或索引扫描。
- 常见语句：SELECT ... FOR UPDATE、SELECT ... LOCK IN SHARE MODE、UPDATE、DELETE。
- 锁的粒度：对索引记录及其前后间隙加锁，形成临键锁，防止在范围内插入新行。

### 示例

假设表和索引如下：

```
CREATE TABLE t (
  id INT PRIMARY KEY,
  c INT,
  KEY idx_c (c)
);
```

事务 A：

```
START TRANSACTION;
SELECT * FROM t WHERE c BETWEEN 10 AND 20 FOR UPDATE;
```

在 REPEATABLE READ 下，InnoDB 会对索引范围加临键锁，锁住 [10, 20] 之间的记录和间隙。
事务 B 在该范围插入会被阻塞：

```
INSERT INTO t (id, c) VALUES (100, 15);
```

在 READ COMMITTED 下，范围内已有记录会被记录锁锁住，但一般不锁间隙，
因此可能允许在范围内插入新行，产生幻读。

### 小结

- 间隙锁不是显式语法，而是 InnoDB 为避免幻读自动加上的锁。
- 是否加间隙锁取决于隔离级别和语句是否触发范围扫描或锁定读。

### 隔离级别速查

| 级别 | 脏读 | 不可重复读 | 幻读 | 实现机制 |
|------|------|-----------|------|---------|
| READ UNCOMMITTED | ✗ | ✗ | ✗ | 无 |
| READ COMMITTED | ✓ | ✗ | ✗ | MVCC（每次新建 Read View） |
| REPEATABLE READ | ✓ | ✓ | 部分✓ | MVCC + 间隙锁 |
| SERIALIZABLE | ✓ | ✓ | ✓ | 全部加锁 |

### 锁类型速查

| 锁类型 | 锁定范围 | 用途 |
|--------|----------|------|
| 记录锁 | 单行记录 | 防止其他事务修改特定行 |
| 间隙锁 | 索引间隙 | 防止在间隙中插入数据 |
| 临键锁 | 记录+间隙 | InnoDB 默认行锁，防止幻读 |
| 意向锁 | 表级 | 快速判断表中是否有行锁 |

### MVCC 核心概念

| 概念 | 说明 |
|------|------|
| DB_TRX_ID | 最近修改该行的事务 ID |
| DB_ROLL_PTR | 指向该行上一版本的指针 |
| Read View | 事务的一致性快照视图 |
| Undo Log | 存储行数据的历史版本 |

---

*本文档涵盖了 MySQL 事务隔离级别和并发控制的核心知识。如有错误或建议，欢迎指正。*
